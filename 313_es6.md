### Modernes JavaScript
Eine von JavaScripts größten Stärken ist, dass es auf quasi allen mit dem Internet verbundenen Konsumergeräten mit Hilfe des Browsers ausgeführt werden kann. Dies ist gleichzeitig auch die markanteste Achillesferse der Sprache: Durch die große Anzahl an unterschiedlichen Geräten und den darauf eingesetzten Browsern und Browserversionen geht eine starke Fragmentierung der verfügbaren Sprachfeatures einher. Da JavaScript nicht als Binärcode an die verschiedenen Geräte verbreitet sondern der Quelltext erst auf diesen interpretiert wird, ist es nicht ohne weiteres möglich neue Versionen der Sprache einzusetzen.

Um mit dieser Problematik umzugehen gibt es zwei unterschiedliche vorherrschende Ansätze:

  a) Die Zielgruppe eingrenzen und anhand von Statistiken die in dieser Gruppe verbreiteten Geräte, Browser und Browserversionen sondieren und auf Grund dieser festlegen, welche Version der Sprache man einsetzt, oder
  b) den Quelltext vor Verteilung an die Nutzer in eine weit verbreitete ältere Version übersetzen.

Der erste Ansatz war lange Zeit der Vorherrschende ist heute weiterhin relevant und gleichermaßen problematisch: Zum Beispiel setzen oft besonders groß Unternehmenskunden, wo die eigentlichen Anwender keinen oder nur wenig Einfluss auf die von ihnen eingesetzten Geräte und auf denen laufende Software haben, aus den verschiedensten Gründen auf längst überholte Browser mit nur eingeschränkter Funktionalität. Es gilt also genau zu bestimmen wo man die Grenze zieht.

Ansatz zwei verfolgt die Idee der [Transcompilierung](#glossar). Transcompilierung beschreibt die Möglichkeit, JavaScript Quelltext der die nur in den neusten Browsern verfügbare Funktionen einsetzt zu Quelltext welcher auch von älteren Browsern interpretiert werden kann zu übersetzen. In Kombination mit sogenannten [Polyfills](#glossar), Codes welche noch nicht vorhandene Funktionen mithilfe bestehender Funktionen nach implementieren, ergibt sich die Möglichkeit heute schon auf Funktionen zu setzen welche eigentlich noch nicht die breite Masse der eingesetzten Browser erreicht hat.

Allerdings fällt auch bei Ansatz zwei die Problematik der Fragmentierung nicht vollständig weg. Manche von modernen Browsern zur Verfügung gestellten Schnittstellen, wie zum Beispiel das auslösen von Push-Benachrichtigungen auf Smartphones, können nicht durch Transcompilierung oder Polyfills nachgerüstet werden. Daher gilt es beide Ansätze zu kombinieren.

Da Node.js auf die JavaScript Implementierung des Chrome Browsers von Google setzt, gilt die Problematik teilweise auch serverseitig. Selbst die V8 JavaScript Engine, so ihr Name, implementiert meist den neusten Standard der Sprache nicht vollständig.

Durch die Möglichkeit den Übersetzungsschritt komplett zu automatisierbaren ergibt sich allerdings auch eine, je nach Ansicht, große Stärker der Sprache: Durch ihre breite Adoption auf Konsumergeräten und der Wirtschaft entwickelt sie sich rasant weiter. Mithilfe von Transcompilierung kann man nicht nur den aktuellsten Standard, sondern auch nach Wahl aktuell noch experimentelle Funktionalitäten einsetzen.

ECMAScript 6 oder auch ECMAScript 2015 ist die aktuellste offiziell fertiggestellte Ausführung der JavaScript zugrunde liegenden Standardisierung. Im folgenden wird auf einige in der Implementierung des Projekts eingesetzten Besonderheiten der Sprache eingegangen.

#### Arrow-Functions


#### Destructuring
*Notwendiger Abschnitt?*


#### Callback-Hell
oder **Promises** oder **Promises & async/await** oder **Callback Future**

Wie im vorhergehenden Abschnitt beschrieben, sind JavaScripts asynchrone Eigenschaften einer der zentralen Aspekte der Sprache. Mit diese Eigenschaft einher geht die Verwendung von Callbacks um mit Ergebnissen asynchroner Funktionsaufrufe umzugehen. Problematisch wird dieser Ansatz sobald mehrere asynchrone Funktionsaufrufe voneinander abhängen und dadurch in ihren jeweiligen Callbacks ineinander verschachtelt werden. Durch die Möglichkeit von theoretisch unendlich vielen in einander verschachtelten Aufrufen wird diese Eigenschaft von Kritikern oft als Callback-Hell bezeichnet.[^citation required] Beispielhaft wird diese Schachtlung in Listing @lst:callback_hell dargestellt: Das Ergebnis der Datenbankanfrage (in diesem und folgenden Beispielen durch Aufruf der Funktion `query` auf dem Objekt `DB` symbolisiert) mit Query `SELECT_A` ist für den zweiten Query, `SELECT_B`, notwendig. Um diese Abhängigkeit zu erfüllen, wird die zweite Anfrage innerhalb des Callbacks der ersten Anfrage ausgeführt.

Listing: Asynchrone verschachtelte Abhängigkeiten mit Callbacks

~~~{.javascript #lst:callback_hell}
DB.query(SELECT_A, result_a => {
  DB.query(SELECT_B, result_b => {
    // Do something with the complete result here.
  });
});
~~~

Außerdem problematisch sind Situationen in denen Code zwar von dem Ergebnis der beiden Datenbankabfragen, aber die beiden Datenbankanfragen nicht untereinander in Abhängigkeit stehen. Um eine möglichst gute Performance zu erhalten ist es in solchen Situationen von Interesse die beiden Queries gleichzeitig auszuführen -- in Listing @lst:callback_hell werden sie, auch wenn sie theoretisch voneinander unabhängig sind, erst nacheinander ausgeführt. Listing @lst:callback_all geht dieses Problem mithilfe der `get_unified_result` Funktion an: Die beiden Queries werden unabhängig voneinander gleichzeitig ausgeführt und rufen beide die Callback-Funktion auf, falls der jeweils andere Query bereits ausgeführt wurde.

Listing: Asynchrone Abhängigkeiten mit Callbacks

~~~{.javascript #lst:callback_all}
function get_unified_result(callback) {
  var result = { a: false, b: false };

  DB.query(SELECT_A, data => { 
    result.a = data; 
    if (result.b) { callback(result); }
  });

  DB.query(SELECT_B, data => { 
    result.b = data; 
    if (result.a) { callback(result); }
  });
}

get_unified_result(result => {
  // Do something with the complete result here.
});
~~~

Mit \ac{ES6} hielten sogenannte *Promise*-Objekte Einzug in die Sprache. Diese sind gewissermaßen Versprechen die ein asynchroner Programmaufruf dem aufrufenden Code macht, auf deren Einhalten (*resolve*) oder Brechen (*reject*) er reagieren kann. In @lst:promises_all macht die `get_complete_result` Funktion ein Versprechen, gibt also ein Promise-Objekt zurück, welches den Erfolg von zwei Datenbankanfragen beinhaltet. Mithilfe von `then` kann auf die Komplettierung der beiden Anfragen reagiert werden: `result` ist wiederum ein Array was bei Erfolg die beiden Ergebnisse beinhaltet.

Listing: Asynchrone Abhängigkeiten mit Promises

~~~{.javascript #lst:promises_all}
function get_complete_result() {
  return Promise.all([
    DB.query(SELECT_A),
    DB.query(SELECT_B),
  ]).then(result => {
    return { a: result[0], b: result[1] };
  });
}

get_complete_result().then(result => {
  // Do something with the complete result here.
});
~~~

Außerdem für eine zukünftige Iteration der Sprache in Arbeit ist das Konzept von sogenannten `async/await`-Generatoren. Diese eröffnen, wie in Listing @lst:generator_all dargestellt, die Möglichkeit, asynchrone Operationen so zu behandeln als ob sie synchrone Operationen wären. Hierbei ist wichtig anzumerken, dass dadurch nicht das bestehende Konzept der Promises ersetzt wird. Vielmehr eröffnen sie die Möglichkeit, innerhalb einzelner Funktionen sequentiellen Code schreiben zu können, wenn in ihr viele aufeinanderfolgende asynchrone Operationen voneinander abhängen. Eine solche mit dem Schlüsselwort `async` markierten Funktion retourniert selbst ein Promise-Objekt.

Listing: Asynchrone Abhängigkeiten mit Generatoren

~~~{.javascript #lst:generator_all}
async function get_complete_result() {
  const result = await Promise.all([
    DB.query(SELECT_A),
    DB.query(SELECT_B),
  ]);

  return { a: result[0], b: result[1] };
}

get_complete_result().then(result => {
  // Do something with the complete result here.
});
~~~

Durch die Kombination von Promises und Generatoren können so die eigentlichen Callbacks und die durch sie entstehende tiefe Verschachtlung von Code als einer von vielen als der größte Nachteil von JavaScript beschriebene Paradigma vermieden werden.
