### Modernes JavaScript
Eine von JavaScripts größten Stärken ist, dass es auf quasi allen mit dem Internet verbundenen Konsumergeräten mit Hilfe des Browsers ausgeführt werden kann. Dies ist gleichzeitig auch die markanteste Achillesferse der Sprache: Durch die große Anzahl an unterschiedlichen Geräten und den darauf eingesetzten Browsern und Browserversionen geht eine starke Fragmentierung der verfügbaren Sprachfeatures einher. Da JavaScript nicht als Binärcode an die verschiedenen Geräte verbreitet sondern der Quelltext erst auf diesen interpretiert wird, ist es nicht ohne weiteres möglich neue Versionen der Sprache einzusetzen.

Um mit dieser Problematik umzugehen gibt es zwei unterschiedliche vorherrschende Ansätze:

  a) Die Zielgruppe eingrenzen und anhand von Statistiken die in dieser Grupper verbreitete Geräte und Browser(versionen) sondieren und anhand dieser festlegen welche Version der Sprache man einsetzt, oder
  b) den Quelltext vor Verteilung an die Nutzer in eine weit verbreitete ältere Version übersetzen.

Der erste Ansatz war lange Zeit der Vorherrschende ist heute weiterhin relevant und gleichermaßen problematisch: Zum Beispiel setzen oft besonders groß Unternehmenskunden, wo die eigentlichen Anwender keinen oder nur wenig Einfluss auf die von ihnen eingesetzten Geräte und auf denen laufende Software haben, aus den verschiedensten Gründen auf längst überholte Browser mit nur eingeschränkter Funktionalität. Es gilt also genau zu bestimmen wo man die Grenze zieht.

Ansatz zwei verfolgt die Idee der [Transcompilierung](#glossar). Transcompilierung beschreibt die Möglichkeit, JavaScript Quelltext der die nur in den neusten Browsern verfügbare Funktionen einsetzt zu Quelltext welcher auch von älteren Browsern interpretiert werden kann zu übersetzen. In Kombination mit sogenannten [Polyfills](#glossar), Codes welche noch nicht vorhandene Funktionen mithilfe bestehender Funktionen nach implementieren, ergibt sich die Möglichkeit heute schon auf Funktionen zu setzen welche eigentlich noch nicht die breite Masse der eingesetzten Browser erreicht hat.

Allerdings fällt auch bei Ansatz zwei die Problematik der Fragmentierung nicht vollständig weg. Manche von modernen Browsern zur Verfügung gestellten Schnittstellen, wie zum Beispiel das auslösen von Push-Benachrichtigungen auf Smartphones, können nicht durch Transcompilierung oder Polyfills nachgerüstet werden. Daher gilt es beide Ansätze zu kombinieren.

Da Node.js auf die JavaScript Implementierung des Chrome Browsers von Google setzt, gilt die Problematik teilweise auch serverseitig. Selbst die V8 JavaScript Engine, so ihr Name, implementiert meist den neusten Standard der Sprache nicht vollständig.

Durch die Möglichkeit den Übersetzungsschritt komplett zu automatisierbaren ergibt sich allerdings auch eine, je nach Ansicht, große Stärker der Sprache: Durch ihre breite Adoption auf Konsumergeräten und der Wirtschaft entwickelt sie sich rasant weiter. Mithilfe von Transcompilierung kann man nicht nur den aktuellsten Standard, sondern auch nach Wahl aktuell noch experimentelle Funktionalitäten einsetzen.

ECMAScript 6 oder auch ECMAScript 2015 ist die aktuellste offiziell fertiggestellte Ausführung der JavaScript zugrunde liegenden Standardisierung. Im folgenden wird auf einige in der Implementierung des Projekts eingesetzten Besonderheiten der Sprache eingegangen.

#### Arrow-Functions




#### Callback-Hell
oder **Promises** oder **Promises & async/await** oder **Callback Future**

Wie im vorhergehenden Abschnitt beschrieben, sind JavaScripts asynchrone Eigenschaften einer der zentralen Aspekte der Sprache. Mit diese Eigenschaft einher geht die Verwendung von Callbacks um mit Ergebnissen asynchroner Funktionsaufrufe umzugehen. Problematisch wird dieser Ansatz sobald mehrere asynchrone Funktionsaufrufe voneinander abhängen und dadurch in ihren jeweiligen Callbacks ineinander verschachtelt werden. Durch die Möglichkeit von theoretisch unendlich vielen in einander verschachtelten Aufrufen wird diese Eigenschaft von Kritikern oft als Callback-Hell bezeichnet.[^citation required]

Eine weitere Problematik liegt in der Möglichkeit, dass Programmcode von den Ergebnissen mehrerer asynchroner Aufrufe abhängt. Die dafür notwendige Logik resultiert sich möglicherweise oft wiederholenden unübersichtlichen Strukturen wie in Listing @lst:callback_all dargestellt.

Listing: Asynchrone Abhängigkeiten mit Callbacks

~~~{.javascript #lst:callback_all}
function get_complete_result(callback) {
  let result = [];
  function done(target, data) {
    result.push(data);
    if (result.length === 2) {
      callback(result);
    }
  }

  DB.query(SELECT_A, data => done(data));
  DB.query(SELECT_B, data => done(data));
}

get_complete_result(result => {
  // do something with the complete result
});
~~~

Mit \ac{ES6} hielten sogenannte Promises Einzug in die Sprache. Diese sind gewissermaßen Versprechen die ein asynchroner Programmaufruf dem aufrufenden Code macht, auf deren Einhalten oder Brechen er reagieren kann. In @lst:promises_all macht die `get_complete_result` Funktion ein Versprechen, gibt als ein Promise-Objekt zurück, welches den Erfolg von zwei Datenbankanfragen beinhaltet. Mithilfe von `then` kann auf die Komplettierung der beiden Anfragen reagiert werden: `result` ist wiederum ein Array was bei Erfolg die beiden Ergebnisse beinhaltet.

Listing: Asynchrone Abhängigkeiten mit Promises

~~~{.javascript #lst:promises_all}
function get_complete_result() {
  return Promise.all([
    DB.query(SELECT_A),
    DB.query(SELECT_B),
  ]);
}

get_complete_result().then(result => {
  // do something with the complete result
});
~~~

Außerdem für eine zukünftige Iteration der Sprache in Arbeit ist das Konzept von `async/await` Generatoren. Diese eröffnen, wie in Listing @lst:generator_all dargestellt, die Möglichkeit, asynchrone Operationen so zu behandeln als ob sie synchrone Operationen wären. Hierbei ist wichtig anzumerken, dass hierbei nicht angedacht wird Promises zu ersetzen. Vielmehr geht es darum, einzelne Funktionen linear gestaltbar zu machen, wenn sie auf eine Vielzahl von linear voneinander abhängigen asynchronen Operationen abhängt. Diese Funktionen selbst werden dann vom umliegenden Programmcode weiter mit Hilfe von Promises und Callback angesprochen.

Listing: Asynchrone Abhängigkeiten mit Generatoren

~~~{.javascript #lst:generator_all}
function async get_complete_result() {
  return await Promise.all([
    DB.query(SELECT_A),
    DB.query(SELECT_B),
  ]);
}

const result = await get_complete_result();
// do something with the complete result
~~~
